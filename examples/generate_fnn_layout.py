#!/usr/bin/env python3

# @file generate_fnn_layout.py
#
# @date April, 2025
# @author Gino Francesco Bogo

import datetime

HEADER_H = """
// -----------------------------------------------------------------------------
// @file fnn_layout.h
//
// @date {date}
//
// @author Generated by generate_fnn_layout.py
// -----------------------------------------------------------------------------

#ifndef FNN_LAYOUT_H
#define FNN_LAYOUT_H

#include <g_page.h>

#define SIZEOF(x) ((int)(sizeof(x) / sizeof(x[0])))

#ifdef __cplusplus
extern "C" {{
#endif

extern g_page_t page[{n_pages}];
extern float    OUT_YT[{out_size}];

g_pages_t fnn_layout_to_pages(void);

#ifdef __cplusplus
}}
#endif

#endif // FNN_LAYOUT_H

// -----------------------------------------------------------------------------
// End of File
"""

HEADER_C = """
// -----------------------------------------------------------------------------
// @file fnn_layout.c
//
// @date {date}
//
// @author Generated by generate_fnn_layout.py
// -----------------------------------------------------------------------------

#include "fnn_layout.h"

{data_arrays}
g_page_t page[{n_pages}];

g_pages_t fnn_layout_to_pages(void) {{
{body}

    return (g_pages_t){{.ptr = page, .len = SIZEOF(page)}};
}}

// -----------------------------------------------------------------------------
// End of File
"""

ACTIVATION_FUNCTIONS = [
    "LINEAR",
    "TANH",
    "RELU",
    "LEAKY_RELU",
    "PRELU",
    "SWISH",
    "ELU",
    "SIGMOID",
    "SOFTMAX",
]

AF_ARGS_INIT = {
    "LINEAR":    ("{0.0f}", 1),
    "TANH":      ("{0.0f}", 1),
    "RELU":      ("{0.0f}", 1),
    "SIGMOID":   ("{0.0f}", 1),
    "LEAKY_RELU":("{0.01f}", 1),
    "PRELU":     ("{0.01f}", 1),
    "SWISH":     ("{0.01f}", 1),
    "ELU":       ("{0.01f}", 1),
    "SOFTMAX":   ("{0.0f, 0.0f}", 2)
}

def prompt_layers():
    while True:
        try:
            n_layers = int(input("How many layers (including input and output)? "))
            if n_layers < 2:
                print("Must be at least 2 (input and output).")
                continue
            break
        except ValueError:
            print("Please enter a valid integer.")
    layers = []
    for i in range(n_layers):
        while True:
            try:
                n = int(input(f"Number of neurons in layer {i} ({'input' if i==0 else 'output' if i==n_layers-1 else 'hidden'}): "))
                if n < 1:
                    print("Must be at least 1.")
                    continue
                layers.append(n)
                break
            except ValueError:
                print("Please enter a valid integer.")
    return layers

def prompt_activations(n_hidden_output):
    print("\nAvailable activation functions:")
    for idx, name in enumerate(ACTIVATION_FUNCTIONS):
        print(f"  {idx}: {name}")
    activations = []
    for i in range(n_hidden_output):
        # Default: LEAKY_RELU for hidden, SIGMOID for output
        if i < n_hidden_output - 1:
            default_idx = ACTIVATION_FUNCTIONS.index("LEAKY_RELU")
        else:
            default_idx = ACTIVATION_FUNCTIONS.index("SIGMOID")
        while True:
            inp = input(f"Select activation for layer {i+1} [{default_idx}]: ").strip()
            if not inp:
                idx = default_idx
            else:
                try:
                    idx = int(inp)
                except ValueError:
                    print("Please enter a valid integer index.")
                    continue
            if 0 <= idx < len(ACTIVATION_FUNCTIONS):
                activations.append(ACTIVATION_FUNCTIONS[idx])
                break
            else:
                print("Please enter a valid index from the list.")
    return activations

def prompt_learning_rates(n_hidden_output):
    learning_rates = []
    for i in range(n_hidden_output):
        while True:
            lr = input(f"Learning rate for layer {i+1} (default 0.01): ").strip()
            if not lr:
                lr = "0.01"
            try:
                learning_rates.append(float(lr))
                break
            except ValueError:
                print("Please enter a valid number.")
    return learning_rates

def generate_data_arrays(layers, activations, learning_rates):
    n_layers = len(layers)
    lines = []
    for i in range(n_layers):
        lname = f"L{i:02d}"
        block = []
        if i == 0:
            block.append(("float", f"{lname}_Y[{layers[i]}]", "= {0.0f};"))  # vector
            lines.append(f"// layer {i}: input layer")
        else:
            act = activations[i-1]
            lr = learning_rates[i-1]
            af_args_init, af_args_len = AF_ARGS_INIT.get(act, ("{0.0f}", 1))
            lines.append(f"// layer {i}: {'output' if i == n_layers-1 else 'hidden'} layer")
            block.append(("float", f"{lname}_W[{layers[i]}][{layers[i-1]+1}]", "= {{0.0f}};"))  # matrix
            block.extend([
                ("float",             f"{lname}_Z[{layers[i]}]",        "= {0.0f};"),  # vector
                ("float",             f"{lname}_Y[{layers[i]}]",        "= {0.0f};"),  # vector
                ("float",             f"{lname}_dY_dZ[{layers[i]}]",    "= {0.0f};"),  # vector
                ("float",             f"{lname}_dE_dY[{layers[i]}]",    "= {0.0f};"),  # vector
                ("float",             f"{lname}_LR",                    f"= {lr}f;"),
                ("g_act_func_type_t", f"{lname}_AF_TYPE",               f"= {act};"),
                ("float",             f"{lname}_AF_ARGS[{af_args_len}]",f"= {af_args_init};"),  # vector
            ])
        # Alignment
        max_type = max(len(t) for t, n, v in block)
        max_name = max(len(n) for t, n, v in block)
        for t, n, v in block:
            lines.append(f"{t.ljust(max_type)} {n.ljust(max_name)} {v}")
        lines.append("")  # Blank line between layers
    # Target output (for last layer)
    lines.append(f"// layer {n_layers-1}: actual outputs (Y target)")
    lines.append(f"float OUT_YT[{layers[-1]}] = {{0.0f}};\n")  # vector
    return "\n".join(lines)

def generate_linking_body(layers):
    n_layers = len(layers)
    lines = []
    for i in range(1, n_layers):  # Only hidden and output layers
        lname = f"L{i:02d}"
        idx = i - 1  # page[0] = first hidden, page[n_pages-1] = output
        # Determine the input vector for this layer
        if i == 1:
            x_name = "L00_Y"
            x_len = "SIZEOF(L00_Y)"
        else:
            x_name = f"L{i-1:02d}_Y"
            x_len = f"SIZEOF(L{i-1:02d}_Y)"
        assigns = [
            ("l_id",        f"{idx}"),
            ("x.ptr",       f"{x_name}"),
            ("x.len",       f"{x_len}"),
            ("w.ptr",       f"(float *){lname}_W"),
            ("w.row",       f"SIZEOF({lname}_W)"),
            ("w.col",       f"SIZEOF({lname}_W[0])"),
            ("z.ptr",       f"{lname}_Z"),
            ("z.len",       f"SIZEOF({lname}_Z)"),
            ("y.ptr",       f"{lname}_Y"),
            ("y.len",       f"SIZEOF({lname}_Y)"),
            ("dy_dz.ptr",   f"{lname}_dY_dZ"),
            ("dy_dz.len",   f"SIZEOF({lname}_dY_dZ)"),
            ("de_dy.ptr",   f"{lname}_dE_dY"),
            ("de_dy.len",   f"SIZEOF({lname}_dE_dY)"),
            ("lr",          f"{lname}_LR"),
            ("af_type",     f"{lname}_AF_TYPE"),
            ("af_args.ptr", f"{lname}_AF_ARGS"),
            ("af_args.len", f"SIZEOF({lname}_AF_ARGS)"),
        ]
        lines.append(f"    // Layer {i}")
        lines.append(f"    g_page_reset(&page[{idx}]);")
        max_field = max(len(a[0]) for a in assigns)
        for field, value in assigns:
            lines.append(f"    page[{idx}].{field.ljust(max_field)} = {value};")
    return "\n".join(lines)

def main():
    print("Feedforward Neural Network Layout Generator (.h/.c)")
    layers = prompt_layers()
    n_layers = len(layers)
    n_pages = n_layers - 1  # Only hidden and output layers
    activations = prompt_activations(n_pages)
    learning_rates = prompt_learning_rates(n_pages)
    date = datetime.datetime.now().strftime('%B, %Y')

    # --- Generate header file ---
    with open("fnn_layout.h", 'w') as f:
        f.write(HEADER_H.format(
            date=date,
            n_pages=n_pages,
            out_size=layers[-1]
        ))

    print("Header file 'fnn_layout.h' generated successfully.")

    # --- Generate source file ---
    data_arrays = generate_data_arrays(layers, activations, learning_rates)
    linking_body = generate_linking_body(layers)
    with open("fnn_layout.c", 'w') as f:
        f.write(HEADER_C.format(
            date=date,
            data_arrays=data_arrays,
            n_pages=n_pages,
            body=linking_body
        ))
    print("Source file 'fnn_layout.c' generated successfully.")

if __name__ == '__main__':
    main()
